---
title: "What's the analog of software?"
slug: /whats-the-analog-of-software
date: '2022-07-19'
featuredImage: color-squares.jpg
---


I was reading [The Book of Delights by Ross Gay](https://bookshop.org/books/the-book-of-delights-essays/9781616207922) and he mentioned why he writes drafts on paper instead of on the computer. He mentioned his frustration with auto-correct and how it forced his form. I think I heard him share in an interview that he also can't scratch things out, use arrows, etc. The reality is that paper is the analog form of writing. 

I'll define analog as the infinite possibilities of something. I'll define digital as a sampling of those infinite possibilities. Film is the analog form of photography, cassettes the analog form of music, what you see with your eye is an analog form of reality. JPeg is a digital form of photography, MP3s are the digital form of music, what we see through a VR headset is a digial form of reality. The act of digitizing an analog form is an attempt to capture something that is infinite in descrete chunks. It's a lesser form of its analog counterpart.

There are no restrictions when we write on paper. I could write in a circle or square instantly. I could use whatever punctuation I wanted. On a computer this would take some effort and I wonder if effort limits our creativity. I think that's why Ross Gay uses paper.

I wonder if writing software on a computer suffers from the same problem. Is it possible that there is an analog version of code? I wonder if it is a list of instructions or maybe it's a pieace of art. I've started to think how I can write analog code. There must be infinite possibilities. 

Here's an example of an analog program for flipping an integer -123. 

1. Create a stack of the original numbers: [1, 2, 3]
2. Pop the numbers: 321
3. Optional: Add a negative in front if needed: -321

As I write this, I still feel like I'm in a digital space. My brain can gravitate towards the tools I've learned to write programs. Do I need to unlearn this or is this essential? I wonder how someone without software backgrounds would solve this problem.

Maybe the point is our context and culture of software gives us a playground to develop in and makes assumptions. But it fails at letting us challenge these assumptions and have true freedom. The problem is subtle but goes all the way down ot how our hardware is defined. We would probably need to change our entire enviornment to challenge how software can be written, or we could start with paper and wonder how programs could be written better. What would be the easiest way in our head to flip a number? 

For me it'd be:
1. Flip the number: -123 ðŸ‘‰ 321-
2. Flip the sign: 321- ðŸ‘‰ -321
